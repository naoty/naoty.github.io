<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ja">
  <id>https://naoty.github.io/posts/index.atom</id>
  <title>Naoto Kaneko's posts</title>
  <updated>2018-06-08T21:57:00.000+09:00</updated>
  <link rel="self" href="https://naoty.github.io/posts/index.atom"/>
  <author>
    <name>Naoto Kaneko</name>
  </author>
  
  <entry>
    <title>パラメータストアで環境変数を管理する</title>
    <link rel="alternate" href="https://naoty.github.io/posts/33.html"/>
    <id>https://naoty.github.io/posts/33.html</id>
    <updated>2018-06-08T21:57:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>最近、ECSで運用しているRailsアプリの起動時にパラメータストアから環境変数を取得して設定するようにした。</p>
<h2 id="-">背景</h2>
<p>それまでは環境変数はコンテナ定義に指定されていたが、それをパラメータストアを使った方法に移行した。理由としては、機密情報をコンテナ定義の環境変数に設定するのは推奨されていないからだ。</p>
<p>また、開発環境で利用する環境変数が開発者によってバラバラに管理されていた（ローカルの<code>.env</code>ファイルによって管理されていた）ため、新しく開発に参加する際に正しい環境変数が何なのか把握するのが大変だった。</p>
<h2 id="-">パラメータストア</h2>
<p>パラメータストアとは、AWSが提供する階層型ストレージのことで、設定のような軽いデータを安全に管理できる。KMSによる暗号化も可能なので機密情報を含む環境変数の管理に向いていそうだと判断した。</p>
<h2 id="-">環境変数をパラメータストアに移す</h2>
<p>バラバラに管理されていた環境変数をパラメータストアに移した。パラメータストアは階層構造になっており、ある階層下にある値をまとめて取得することができる。</p>
<p>今回は<code>/&lt;アプリケーション名&gt;/&lt;実行環境&gt;/&lt;環境変数名&gt;</code>という階層で環境変数を管理することにした。例えば、<code>/myapp/production/PASSWORD</code>のような感じだ。</p>
<h2 id="-">コンテナからパラメータストアにアクセスする</h2>
<p>ECSコンテナからパラメータストアにアクセスするには権限が必要になる。パラメータストアへの移行と同時並行でECSコンテナでIAMロールを使うように修正していたので、このIAMロールにパラメータストアにアクセスするためのポリシーを付与した。</p>
<h2 id="rails-">Rails起動時に環境変数をセットする</h2>
<p>環境変数はRailsの起動プロセスの中で参照されることがある（データベースとの接続など）ため、起動プロセスの初期に環境変数を設定する必要がある。</p>
<p>いくつかRubygemがあるようだったが、たいした実装ではないので簡単なコードを書いて環境変数を起動プロセスの初期に設定するようにした。</p>
<p>注意点としては、パラメータストアから取得した環境変数よりも既存の環境変数を優先させた点だ。ECSからタスクとしてコンテナを起動するときなど、コンテナ定義から環境変数を指定することでパラメータストアの環境変数を上書きできると便利なケースがあったからだ。また、開発環境では<code>docker-compose.yml</code>で指定した環境変数を優先することも可能になる。</p>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>Circle CIのSlackへの通知を分かりやすくする</title>
    <link rel="alternate" href="https://naoty.github.io/posts/32.html"/>
    <id>https://naoty.github.io/posts/32.html</id>
    <updated>2018-06-08T16:23:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>Circle CI 2.0で導入されたworkflowを使うと、Slackへの通知にどのjobが完了したのかが含まれていなくて困ることがあった。特に失敗したときにどのjobが失敗したのかSlackでは分からないのが不便だった。</p>
<p>そこで、Slackへの通知を分かりやすくするための設定をいくつかしてみたところ、劇的によくなったので紹介したい。</p>
<h1 id="-">通知スクリプトを自作する</h1>
<pre><code class="lang-bash">#!/bin/bash -e

payload=$(cat &lt;&lt; EOS
{
  &quot;attachments&quot;: [
    {
      &quot;title&quot;: &quot;Success&quot;,
      &quot;title_link&quot;: &quot;${CIRCLE_BUILD_URL}&quot;,
      &quot;text&quot;: &quot;\`workflow/${CIRCLE_STAGE}\` in ${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME} (${CIRCLE_BRANCH})&quot;,
      &quot;mrkdwn_in&quot;: [&quot;text&quot;],
      &quot;color&quot;: &quot;good&quot;
    }
  ]
}
EOS
)

curl \
  -X POST \
  -H &#39;Content-Type: application/json&#39; \
  --data &quot;${payload}&quot; \
  ${SLACK_WEBHOOK_URL}
</code></pre>
<ul>
<li>Circle CIの連携時に生成されるWebhookを使って通知を送るスクリプトを書いた。</li>
<li><code>attachments</code>フィールドを使ってリッチなメッセージを作る。</li>
<li>環境変数<code>CIRCLE_STAGE</code>には、workflow内で実行中のjob名が入っているため、これを使ってどのjobが成功したのか失敗したのかを通知できる。</li>
</ul>
<h1 id="-">通知スクリプトを設定する</h1>
<pre><code class="lang-yaml">jobs:
  test:
    steps:
      # ...
      - run: ./.circleci/notify-success
      - run:
          command: ./.circleci/notify-failure
          when: on_fail
</code></pre>
<ul>
<li>各jobの最後のstepに成功時の通知を送るスクリプトを設定する。</li>
<li><code>when: on_fail</code>を設定すると、先に実行されたstepが失敗したときに呼ばれるstepを設定できる。それを利用して、失敗時の通知を送るスクリプトを設定する。</li>
</ul>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>docker-composeでwebpack-dev-serverを使う</title>
    <link rel="alternate" href="https://naoty.github.io/posts/31.html"/>
    <id>https://naoty.github.io/posts/31.html</id>
    <updated>2018-06-06T23:04:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>docker-composeを使って開発をしているとき、webpack-dev-serverを別サービスとして起動させたくなる。Rails + webpackerの環境でうまく実現できたのでメモを残しておく。</p>
<p><code>docker-compose.yml</code>のうちポイントとなる箇所だけ抽出した。</p>
<pre><code class="lang-yaml">services:
  rails:
    environment:
      WEBPACKER_DEV_SERVER_HOST: webpack-dev-server
    volumes:
      - ./public/packs:/myapp/public/packs
    depends_on:
      - webpack-dev-server
  webpack-dev-server:
    environment:
      WEBPACKER_DEV_SERVER_HOST: 0.0.0.0
    ports:
      - 3035:3035
    volumes:
      - ./public/packs:/myapp/public/packs
</code></pre>
<h1 id="webpacker-webpack-dev-server">webpackerとwebpack-dev-server</h1>
<p>webpackerをセットアップするとwebpack-dev-serverもついてくる。そして、<code>config/webpacker.yml</code>にはwebpack-dev-serverの設定も含まれている。</p>
<p>開発環境において、webpackerはアセットへのリクエスト受信時にwebpackを実行してアセットをコンパイルするが、webpack-dev-serverの起動が確認できればアセットへのリクエストをwebpack-dev-serverに転送するようになっている。</p>
<p>Railsがwebpack-dev-serverに接続する際、<code>config/webpacker.yml</code>に記載されたhostとportを参照する。ただし、<code>WEBPACKER_DEV_SERVER_*</code>のようなパターンの環境変数を設定することでYAMLファイルの設定を上書きできるようになっており、それを利用しているのが、上の<code>docker-compose.yml</code>内で指定している環境変数<code>WEBPACKER_DEV_SERVER_HOST</code>となる。これでwebpack-dev-serverのhostを設定できる。</p>
<p>このdocker-composeでは、<code>depends_on</code>で設定したサービスのaliasを設定することでRailsからwebpack-dev-serverにアクセスできるようにしている。また、<code>webpack-dev-server</code>サービスで<code>0.0.0.0</code>を指定しているのは、このコンテナ外からアクセスできるようにするためだ。</p>
<h1 id="-">マニフェストファイルの共有</h1>
<p>Railsがwebpackでコンパイルしたアセットにアクセスする際、マニフェストファイルに記載されたアセットのファイルパスを利用している。マニフェストファイルはコンパイル時に生成されるため、webpack-dev-serverを実行するコンテナでマニフェストファイルが生成されることになる。</p>
<p>そこで、マニフェストファイルが生成される<code>public/packs</code>ディレクトリをホストとマウントすることでRailsコンテナからマニフェストファイルを参照できるようにしている。</p>
<h1 id="live-reload">live reload</h1>
<p>webpack-dev-serverはアセットのソースコードが変更されたときにブラウザを自動更新させるlive reloadの機能も備えている。live reloadはwebpack-dev-serverがアセットをコンパイルする際にlive reloadするスクリプトを挿入することで実現している（はず）。そのスクリプトはwebpack-dev-serverを参照するため（ここら辺の詳しい仕組みはちゃんと把握できていない）、3025番でホストとのポートマッピングを行っている。</p>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>zshに戻った</title>
    <link rel="alternate" href="https://naoty.github.io/posts/30.html"/>
    <id>https://naoty.github.io/posts/30.html</id>
    <updated>2018-05-16T21:34:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>1年くらい前からシェルはfishを使っていたけど、最近zshに戻ってきた。理由としては、当時はやってなかったインフラの作業がメインの業務になり、シェルスクリプトを書くようになったからだ。fishはbashとの互換性がないので、bashを書くときに頭を切り替えるのが少しずつストレスになってきた。</p>
<p>fishを使っていた頃は<a href="https://github.com/fisherman/fisherman">fisherman</a>というプラグインマネージャーを使っていたけど、zshでもプラガブルな設定は続けていきたいので<a href="https://github.com/zplug/zplug">zplug</a>を使い始めた。</p>
<p>相変わらずzshのプラグインはいい感じのものがないので、またも自分で<a href="https://github.com/naoty/prompt">プロンプト</a>を書くことになった。世の中の人気のあるプロンプトのテーマは余計な情報が多くて重いので、結局いつも自分で書くことになっている。<a href="https://github.com/sindresorhus/pure">pure</a>はよさそうだったけど、二列に慣れず惜しくも採用できなかった。</p>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>CourseraのMachine Learningを受講しはじめた</title>
    <link rel="alternate" href="https://naoty.github.io/posts/29.html"/>
    <id>https://naoty.github.io/posts/29.html</id>
    <updated>2018-05-01T21:47:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>5月から<a href="https://www.coursera.org/learn/machine-learning">CourseraのMachile Learning</a>を受講しはじめた。</p>
<p>正月からちょっとずつ機械学習の勉強をしているけど、それは40代以降もプログラマーとして働き続けたいと思っているからだ。あと10年くらいは今の知識や経験で活躍できるかもしれないけど、ずっとプログラマーでいるには新しい技術領域に時間をかけたいと思った。まずはCoursera等で勉強し、少しずつ仕事として機械学習に取り組んでいけるようにしたい。</p>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>awscliのwaitコマンドが便利だった</title>
    <link rel="alternate" href="https://naoty.github.io/posts/28.html"/>
    <id>https://naoty.github.io/posts/28.html</id>
    <updated>2018-04-22T09:55:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>ECSにデプロイするスクリプトを書くとき、<code>wait</code>コマンドがとても便利だった。</p>
<p>デプロイする前にいくつかのECSタスクを実行し完了を待ってからデプロイしたい場合、ECSタスクのステータスをポーリングして完了したかどうかを監視する必要がある。<code>aws ecs run-task</code>は即座に終了し、タスクの実行自体は非同期に行われるからだ。</p>
<p>そうしたとき、<code>wait</code>コマンドを使うと簡単にポーリングを行うことができる。</p>
<pre><code class="lang-bash">aws ecs wait tasks-stopped --tasks ${task_arn1} ${task_arn2}
</code></pre>
<p>これは<code>aws ecs describe-tasks</code>を定期的に実行してレスポンスからステータスを取得し、それが完了するまで待つ。<code>--tasks</code>オプションはECSタスクのARNを複数指定できるので、複数のタスクがすべて完了するのを待つことができる。</p>
<p>ECSタスクのARNは<code>aws ecs run-task</code>のレスポンスから取得できる。実際にはこんな感じで書くと思う。</p>
<pre><code class="lang-bash">task_arn1=$(aws ecs run-task \
  --task-definition my-task-definition \
  --query &quot;tasks[0].taskArn&quot; \
  --output text)

aws ecs wait tasks-stopped --tasks ${task_arn1}
</code></pre>
<p>気をつける必要があるのは、ECSタスクが完了したかどうかは分かるものの、それが成功したのか失敗したのかは分からないということだ。なので、<code>wait</code>の後で<code>describe-tasks</code>によって失敗したかどうかをチェックする必要があるとおもう。</p>
<p><code>wait</code>コマンドはタスクの完了だけでなくサービスのステータスの監視でも使えるし、またECS以外にもEC2などで使えるのでawscliを使ったスクリプトを書くときには今後もお世話になりそう。</p>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>作業メモという習慣</title>
    <link rel="alternate" href="https://naoty.github.io/posts/27.html"/>
    <id>https://naoty.github.io/posts/27.html</id>
    <updated>2018-04-14T17:16:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>数ヶ月前から開発するときに作業メモをとりながら開発をするようにしている。スクショのようにエディタを上下に分割して上で作業しながら下でメモをとっている。</p>
<p><img src="/images/posts/27/atom.png" alt="atom.png"></p>
<p>作業メモという習慣を数ヶ月続けてみていいことが多かった。</p>
<ul>
<li>デバッグするときは、どこにバグがあるか仮説を作業メモにとりながら進める。頭の中だけでこれを行うのはけっこう大変で、脳のメモリが食いつぶされるのを感じる。</li>
<li>作業が煮詰まったときに、これまでの作業を振り返るきっかけにもなる。</li>
<li>土日や休日を挟んでから作業に戻るとき、どこまで何をしていたのか作業を振り返るときに便利だったりする。</li>
<li>作業内容やそこから得られた知見を他人と共有する際に、作業メモをベースにしやすい。</li>
</ul>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>RailsからReduxのinitial stateを設定する</title>
    <link rel="alternate" href="https://naoty.github.io/posts/26.html"/>
    <id>https://naoty.github.io/posts/26.html</id>
    <updated>2018-03-29T23:19:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <pre><code class="lang-rb">def new
  @user = User.new
end
</code></pre>
<p>上のようなコントローラーで作ったデータをReduxのinitial stateとして設定したいと思い、いろいろ考えて書いてみた。</p>
<p>まず、ヘルパーとかデコレーターでモデルをReactコンポーネントに渡すpropsに変換してみる。今回はactive_decoratorを使う。</p>
<pre><code class="lang-rb">module UserDecorator
  def to_react_props
    as_json(only: %i[first_name last_name email])
      .transform_keys { |key| key.camelcase(:lower) }
      .transform_values { |value| value || &quot;&quot; }
      .to_json
  end
end
</code></pre>
<p>これでモデルから必要な属性だけをcamelCaseのJSON文字列に変換できるようになった。</p>
<p>次にRailsのviewでdata属性に上のpropsを渡す。あとでここからJSでデータを引っ張ってくる計画だ。</p>
<pre><code class="lang-erb">&lt;div id=&quot;js-redux-root&quot; data-react-props=&quot;&lt;%= @user.to_react_props %&gt;&quot;&gt;
&lt;/div&gt;
</code></pre>
<p>あとは、Reduxのstoreを作成するときに上のpropsを設定する。</p>
<pre><code class="lang-javascript">document.addEventListener(&#39;DOMContentLoaded&#39;, () =&gt; {
  const rootElement = document.getElementById(&#39;js-redux-root&#39;);
  const initialState = JSON.parse(rootElement.dataset.reactProps);
  const store = createStore(rootReducer, initialState);

  render(
    &lt;Provider store={store}&gt;
      &lt;SignUpForm /&gt;
    &lt;/Provider&gt;
  );
});
</code></pre>
<p>これでRailsで作ったデータをReduxのinitial stateに設定できた。フォームの初期値を埋めておきたいときなど、コントローラーからReactコンポーネントにデータを渡せるとラクなので、こういう実装が必要になると思う。</p>
<p>最近、ReactとかReduxを勉強しているので、これでいいのかよくわかりません。コードレビューお願いします。</p>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>webpackerにjestを導入する</title>
    <link rel="alternate" href="https://naoty.github.io/posts/25.html"/>
    <id>https://naoty.github.io/posts/25.html</id>
    <updated>2018-03-20T19:56:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>webpackerを使ったRailsプロジェクトにjestを導入してみた。jestをインストールしてテストを実行してみると、以下のようなエラーがおきた。</p>
<pre><code>({&quot;Object.&lt;anonymous&gt;&quot;:function(module,exports,require,__dirname,__filename,global,jest){import xxx from &#39;./xxx&#39;;
                                                                                         ^^^^^^

SyntaxError: Unexpected token import
  at ScriptTransformer._transformAndBuildScript (node_modules/jest-runtime/build/script_transformer.js:316:17)
</code></pre><p>importがコンパイルできていないようだ。webpackerが生成する<code>.babelrc</code>では、以下のように設定されている。</p>
<pre><code class="lang-json">{
  &quot;presets&quot;: [
    [&quot;env&quot;, {
      &quot;modules&quot;: false,
      &quot;targets&quot;: {
        &quot;browsers&quot;: &quot;&gt; 1%&quot;,
        &quot;uglify&quot;: true
      },
      &quot;useBuiltIns&quot;: true
    }],
    &quot;react&quot;
  ]
}
</code></pre>
<p><code>&quot;modules&quot;: false</code>と設定されているため、<code>import</code>の変換が行われないようになっている。これはwebpackによって<code>import</code>文を処理するためにbabelでは<code>import</code>の変換を行わないようにしているんだと思う。</p>
<p>しかし、jestを実行する場合はwebpackによる処理は行われないため、<code>import</code>が変換されずエラーになっていたと考えられそう。</p>
<p>そこで、以下の設定を<code>.babelrc</code>に追加したところ直った。</p>
<pre><code class="lang-json">{
  &quot;env&quot;: {
    &quot;test&quot;: {
      &quot;presets&quot;: [
        [&quot;env&quot;, { &quot;modules&quot;: &quot;commonjs&quot; }]
      ]
    }
  }
}
</code></pre>
<p>jestは実行時に自動的に<code>NODE_ENV</code>を<code>test</code>に設定するため、これでうまくいく。</p>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>bin/webpackに必要最小限のファイル</title>
    <link rel="alternate" href="https://naoty.github.io/posts/24.html"/>
    <id>https://naoty.github.io/posts/24.html</id>
    <updated>2018-03-13T21:22:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p><a href="https://naoty.github.io/posts/23.html">前回</a>と同様にwebpackerによるbundleに必要最小限なファイルの<code>COPY</code>を試してみた。</p>
<pre><code class="lang-dockerfile">FROM starefossen/ruby-node:2-8-alpine
WORKDIR /myapp

COPY app/javascript /myapp/app/javascript/
COPY bin/webpack /myapp/bin/
COPY config/webpack /myapp/config/webpack/
COPY config/webpacker.yml /myapp/config/webpacker.yml
COPY .babelrc .postcssrc.yml /myapp/
COPY Gemfile Gemfile.lock /myapp/
COPY --from=bundler /usr/local/bundle /usr/local/bundle
RUN bin/webpack
</code></pre>
<ul>
<li>webpackerを使うにはRubyとNodeの両方が必要になるため両方が入ったベースイメージを探したところ、<a href="https://hub.docker.com/r/starefossen/ruby-node/">starefossen/ruby-node</a>がよさそうだった。</li>
<li><code>COPY --from=bundler</code>としているところは、<a href="https://docs.docker.com/develop/develop-images/multistage-build/">multi-stage build</a>を使っている。前段のビルドで<code>bundle install</code>しておいたものを<code>COPY</code>している。こうすることで実行時には不要なものを除くことができる。このビルド自体もRailsを起動するために必要なファイルを生成するビルドにすぎない。</li>
</ul>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>Assets precompileに必要最小限のファイル</title>
    <link rel="alternate" href="https://naoty.github.io/posts/23.html"/>
    <id>https://naoty.github.io/posts/23.html</id>
    <updated>2018-03-09T20:55:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>Dockerfileで<code>rails assets:precompile</code>を実行する前に<code>COPY</code>するファイルを必要最小限にしておけると、キャッシュを有効活用できてビルド時間を短縮できる。</p>
<pre><code class="lang-dockerfile">WORKDIR /myapp

COPY app/assets /myapp/
COPY bin/rails /myapp/bin/
COPY config/environments /myapp/config/environments/
COPY config/initializers /myapp/config/initializers/
COPY config/application.rb /myapp/config/application.rb
COPY config/boot.rb /myapp/config/boot.rb
COPY config/environment.rb /myapp/config/environment.rb
COPY config/secrets.yml.enc /myapp/config/secrets.yml.enc
COPY lib/assets /myapp/lib/assets/
COPY vendor/assets /myapp/vendor/assets/
COPY Rakefile /myapp/
RUN bin/rails assets:precompile
</code></pre>
<p>とりあえずこれだけで動いた。<code>config/initializers/</code>以下も削れそうな気がするけど、プロジェクトによってケースバイケースだと思うので、これで十分だとおもう。</p>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>JSONをASCIIテーブルで表示する</title>
    <link rel="alternate" href="https://naoty.github.io/posts/22.html"/>
    <id>https://naoty.github.io/posts/22.html</id>
    <updated>2018-03-05T17:34:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>もともとTSV形式の文字列をASCIIやMarkdown形式のテーブルに変換するコマンドだった<a href="https://github.com/naoty/table">naoty/table</a>を改善して、JSON形式の文字列を受け取れるようにした。</p>
<p>例えば、以下のようなJSONファイルがあったとする。</p>
<pre><code class="lang-json">// pokemons.json
[
  {
    &quot;id&quot;: 1,
    &quot;name&quot;: &quot;bulbasaur&quot;
  },
  {
    &quot;id&quot;: 2,
    &quot;name&quot;: &quot;ivysaur&quot;
  },
  {
    &quot;id&quot;: 3,
    &quot;name&quot;: &quot;venusaur&quot;
  }
]
</code></pre>
<p>このとき、以下のようにパイプで<code>table</code>コマンドに渡すとASCII形式に変換できる。</p>
<pre><code class="lang-shell">$ cat pokemons.json | table -f json:ascii
+----+-----------+
| id | name      |
+----+-----------+
| 1  | bulbasaur |
| 2  | ivysaur   |
| 3  | venusaur  |
+----+-----------+
</code></pre>
<p><code>table</code>コマンドは出力フォーマットとしてMarkdown形式のテーブルも選べるので、以下のように出力できる。</p>
<pre><code class="lang-shell">$ cat pokemons.json | table -f json:markdown
| id | name      |
| -- | --------- |
| 1  | bulbasaur |
| 2  | ivysaur   |
| 3  | venusaur  |
</code></pre>
<h1 id="-">モチベーション</h1>
<p>最近、AWSの作業をすることが増えてAWS CLIから返ってくるJSONを扱うことが増えた。返ってきたJSONを<code>jq</code>コマンドで整形して表示するのだけど、件数が増えるとかなり見にくかった。そこで、このような機能を追加してASCIIテーブルとして見やすくしたかったので追加してみた。</p>
<p>例えば、ECSのあるタスク定義に含まれるイメージを知りたいとき、こんな感じでやることになりそう。</p>
<pre><code class="lang-shell">$ aws ecs describe-task-definition --task-definition hello_world:8 | \
  jq &quot;.taskDefinition.containerDefinitions | map({name: .name, image: .image})&quot; | \
  table -f json:ascii
+-----------+-----------+
| name      | image     |
+-----------+-----------+
| wordpress | wordpress |
| mysql     | mysql     |
+-----------+-----------+
</code></pre>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>MailHogによるメールの受信確認</title>
    <link rel="alternate" href="https://naoty.github.io/posts/21.html"/>
    <id>https://naoty.github.io/posts/21.html</id>
    <updated>2018-02-18T21:53:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>メール送信機能を開発する際、メールの受信を確認したい。従来のRailsアプリ開発では、<a href="https://github.com/ryanb/letter_opener">letter_opener</a>のようなライブラリを使っていた。</p>
<p>現在のコンテナを中心とした開発環境では、Railsの外側にSMTPサーバーのコンテナを用意し、環境変数によって接続先を設定する方法が一般的ではないかと思った。調べてみると、<a href="https://github.com/mailhog/MailHog">MailHog</a>というツールが見つかった。MailHogはSMTPサーバーであり、かつ受信したメールを確認できるHTTPサーバーも兼ね備えている。</p>
<p>MailHogはDocker Hubでコンテナを公開しているため、docker-composeを使うと簡単に開発環境に組み込むことができる。</p>
<pre><code># docker-compose.yml
services:
  web:
    build: .
    command: bin/rails s -p 3000 -b 0.0.0.0
    environment:
      SMTP_HOST: mail
      SMTP_PORT: 1025
    depends_on:
      - mail
  mail:
    image: mailhog/mailhog
    ports:
      - 8025:8025
</code></pre><p>Railsではこんな感じで環境変数によってメールの送信先を設定するだけでいい。</p>
<pre><code># application.rb
config.action_mailer.delivery_method = :smtp
config.action_mailer.smtp_settings = {
  address: ENV[&quot;SMTP_HOST&quot;],
  port: ENV[&quot;SMTP_PORT&quot;],
}
</code></pre><p>本番環境などでは、この環境変数を実際に運用するSMTPサーバーのものに替えるだけでいい。</p>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>react-railsによるCSRF対策</title>
    <link rel="alternate" href="https://naoty.github.io/posts/20.html"/>
    <id>https://naoty.github.io/posts/20.html</id>
    <updated>2018-02-18T12:08:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>最近、react-railsを使ってRails上でReactコンポーネントを実装している。フォームを実装する際、Railsのフォームヘルパーは自動的にCSRFトークンを送るように<code>&lt;input&gt;</code>を生成してくれるが、Reactコンポーネントでフォームを実装する場合はそれを自分で実装する必要がある。</p>
<p>react-railsであれば、Reactコンポーネントにpropsを簡単に渡せるため、props経由でCSRFトークンを渡すことで実装することができる。</p>
<pre><code>// new.html.slim
= react_component &quot;SignUpForm&quot;,
  { csrf_params: request_forgery_protection_token, csrf_token: form_authenticity_token }
</code></pre><pre><code>// SignUpForm.jsx
render() {
  return (
    &lt;form method=&quot;post&quot; action=&quot;/sign_up&quot;&gt;
      &lt;input type=&quot;hidden&quot; name={this.props.csrfParams} value={this.props.csrfToken} /&gt;
    &lt;/form&gt;
  );
}
</code></pre>
      </div>
    </content>
  </entry>
  
  <entry>
    <title>webpacker用のDockerfile</title>
    <link rel="alternate" href="https://naoty.github.io/posts/19.html"/>
    <id>https://naoty.github.io/posts/19.html</id>
    <updated>2018-02-12T22:58:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>webpackerを導入する際にDockerイメージにNode.jsとYarnが必要になるため、以下のようにDockerfileにインストールコマンドを追加する。いつも調べるのが面倒なので、メモしておく。</p>
<pre><code>FROM ruby:2.5.0

# Node.js
RUN curl -sL https://deb.nodesource.com/setup_8.x | bash - &amp;&amp; \
  apt-get install -y nodejs

# Yarn
RUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add - &amp;&amp; \
  echo &quot;deb https://dl.yarnpkg.com/debian/ stable main&quot; | tee /etc/apt/sources.list.d/yarn.list &amp;&amp; \
  apt-get update &amp;&amp; \
  apt-get install -y yarn
</code></pre><h1 id="-">参考</h1>
<ul>
<li><a href="https://nodejs.org/ja/download/package-manager/">https://nodejs.org/ja/download/package-manager/</a></li>
<li><a href="https://yarnpkg.com/ja/docs/install#linux-tab">https://yarnpkg.com/ja/docs/install#linux-tab</a></li>
</ul>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>副業先を探しています</title>
    <link rel="alternate" href="https://naoty.github.io/posts/18.html"/>
    <id>https://naoty.github.io/posts/18.html</id>
    <updated>2018-02-07T22:30:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>土日に働ける副業先を探しています。</p>
<p>できることを活かして収入を増やしつつ本業とは異なる環境でスキルの幅を拡げたいというのが副業の動機です。本業には兼業規定がありいくつかの条件を満たしていれば兼業が可能なので、こういう形でブログで告知してみました。</p>
<h1 id="-">できること</h1>
<ul>
<li>Ruby on Railsを使ったWebアプリケーション開発を2012年頃からしています。案件としては、モバイルアプリのバックエンドで動くAPI開発が多いです。</li>
<li>iOSアプリ開発も4件ほど（Objective-Cが2件、Swiftが2件）携わった経験があります。その内、1件はゼロからSwiftでiOSアプリを開発していました。案件としては、Webサービスのアプリ版の開発がほとんどです。IAPを使った課金機能の開発経験もあります。</li>
<li>現在はサーバーサイドとクライアントサイドの開発経験を活かして開発チームのテックリードをしています。開発方針のとりまとめやビジネスサイドとの開発側窓口としてコミュニケーションをしています。</li>
<li>業務外では、OSS活動や自分で使うツールの開発をしています。主な成果として、Swiftによる日時操作ライブラリである<a href="https://github.com/naoty/Timepiece">Timepiece</a>をGitHubで公開し、2000以上のStarを世界中からいただいています。</li>
</ul>
<h1 id="-">やりたいこと</h1>
<ul>
<li>モダンなWebフロントエンド開発の経験を積みたいです。API開発が多かったためあまり業務で触れてこなかった分野なので、本業とは異なる環境でトライしてみたいことの1つです。</li>
<li>Ruby on Rails以外のサーバーサイド開発もできればやってみたいです。特にPythonまたはGoを使ったサーバーサイド開発に興味があります。どちらとも業務外の時間に書いたことはあるものの、業務レベルでの経験値を積みたいです。</li>
</ul>
<h1 id="-">勤務条件</h1>
<ul>
<li>土日での勤務を希望します。休日にどうしても外せない用がある場合は平日の夜間に対応します。</li>
<li>基本的にはリモートワークをメインとしたいです。出社する場合は東京23区内だと助かります。</li>
</ul>
<h1 id="-">連絡先</h1>
<ul>
<li><a href="https://twitter.com/naoty_k">@naoty_k</a>またはnaoty.k[at]gmail.comにご連絡ください。</li>
</ul>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>TerraformでAWSを学んでいる</title>
    <link rel="alternate" href="https://naoty.github.io/posts/17.html"/>
    <id>https://naoty.github.io/posts/17.html</id>
    <updated>2018-02-03T22:41:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>最近、AWS上にインフラをセットアップする仕事をしている。これまでこうした仕事はしたことがなかったので、新しいことをいろいろ学んでいる。</p>
<p>インフラの構築はTerraformを通して行っているため、コードからAWSについて学ぶことができる。新しいことを学ぶときはだいたい下のようなステップを踏んでいる。</p>
<ol>
<li>Terraformのコード例や社内のTerraformのコードを読む。</li>
<li>コードを理解するためにTerraformのドキュメントを読む。</li>
<li>Terraformのドキュメントを理解するためにAWSのドキュメントを読む。</li>
<li>Terraformのコードを書いてみる。</li>
<li>コードレビューしてもらい、足りない点を補足する。</li>
</ol>
<p>Terraformのおかげでインフラをどのようにセットアップすればいいのかコードを通して理解できるようになった。他のインフラエンジニアの書いたTerraformのコードを読めば、ベストプラクティスを盗むことができる。まだ僕がRailsを始めたての頃はインフラというと、AWSのコンソールをポチポチする作業という感じで掴みにくい感じがしたが、いまはこのような便利なツールのおかげでかなり学習のハードルが下がったと思う。引き続きこの調子でAWSの経験値を効率的にためていきたい。</p>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>FLOCSSを導入した</title>
    <link rel="alternate" href="https://naoty.github.io/posts/16.html"/>
    <id>https://naoty.github.io/posts/16.html</id>
    <updated>2018-02-01T08:48:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>このホームページのCSSを見直して<a href="https://github.com/hiloki/flocss">FLOCSS</a>を導入した。</p>
<p>さまざまなCSSアーキテクチャが提唱されているけど、仕事でFLOCSSが採用されそうなので試しにやってみようということでやってみた。</p>
<p>ディレクトリ構成はこんな感じ。</p>
<pre><code>stylesheets/
├── application.css
├── foundation
│   ├── _base.css
│   └── _variable.css
├── layout
│   └── _base.css
└── object
    ├── project
    │   ├── _homepage.css
    │   ├── _post.css
    │   └── _posts.css
    └── utility
        └── _align.css
</code></pre><p>markdownを変換したHTMLにstyleを与えるという制約上、クラスを使ったstyleを定義しにくい。なので、componentっぽいものもprojectにすべて含めてしまっている。これでいいのかはまだ分かっていないので、他のプロジェクトでも導入して試行錯誤してみたい。</p>
<p>ついでなので、最近意識しているCSSの書き方を挙げておきたい。</p>
<ul>
<li><code>font-size</code>, <code>margin</code>, <code>padding</code>では単位に<code>rem</code>を使う。</li>
<li><code>margin-top</code>を使わない。一貫して<code>margin-bottom</code>を使うことで、シンプルにレイアウトを組むことができる。</li>
<li><code>margin-bottom</code>の値は<code>&lt;h1&gt;</code>~<code>&lt;h6&gt;</code>と<code>&lt;li&gt;</code>を<code>1</code>とすると、その他のブロック要素を<code>2</code>にする。例えば、このブログでは以下のような感じにしている。</li>
</ul>
<pre><code>h1,
h2,
h3,
h4,
h5,
h6,
li {
  margin-bottom: 1rem;
}

p,
ul,
ol,
pre,
table {
  margin-bottom: 2rem;
}
</code></pre>
      </div>
    </content>
  </entry>
  
  <entry>
    <title>PostCSSを導入した</title>
    <link rel="alternate" href="https://naoty.github.io/posts/15.html"/>
    <id>https://naoty.github.io/posts/15.html</id>
    <updated>2018-01-24T16:27:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>このGitHub pagesのstylesheetは、これまでSASSで記述されGulpのパイプラインで処理されたCSSだった。今回、PostCSSを導入した。理由としては、PostCSSを通してマルチブラウザへの効率的な対応やCSSのlintを行いたかったからだ。</p>
<p>PostCSSの導入にともなって、SASSで記述していたstylesheetをcssnextで書き換えた。SASSのような独自記法を覚えるよりも標準的な規格を覚える方が学習コストを回収しやすい。ちょうどCoffeeScriptからECMAScript 6への移行と同じような感じだ。</p>
<p>導入したPostCSSプラグインは以下の通り。</p>
<ul>
<li><code>postcss-cssnext</code>：cssnextを導入する。これでcssで変数を利用したり、ネストした書き方ができる。<code>autoprefixer</code>が内部で使われており、サポートするブラウザに基づいてベンダープレフィックスを付与してくれる。</li>
<li><code>postcss-import</code>：<code>@import</code>で宣言した外部のファイルを1つのファイルにまとめることができる。</li>
<li><code>stylelint</code>：CSSのlintを行う。</li>
<li><code>cssnano</code>：CSSの圧縮を行う。</li>
</ul>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>スキーマファイルをSQL形式に変更する</title>
    <link rel="alternate" href="https://naoty.github.io/posts/14.html"/>
    <id>https://naoty.github.io/posts/14.html</id>
    <updated>2018-01-13T09:53:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>Railsアプリのスキーマファイルはデータベースの現在のスキーマを表し、デフォルトでは<code>db/schema.rb</code>にActiveRecordのDSLで記述されている。スキーマファイルは<code>rails db:schema:dump</code>で生成されるものなので、開発者が直接いじってはならない。</p>
<p>開発が進みデータベースのスキーマが複雑になると、ActiveRecordのDSLでの表現に限界が出てくる。DSLのメリットはデータベースに依存せず抽象的な表現ができることだが、データベース固有の設定をする場合にDSLで表現できなくなってくる。</p>
<p>DSLで表現できなくなるとスキーマファイルと実際のスキーマに乖離が生まれる。スキーマに乖離があると、開発環境やCI上でデータベースをセットアップするのが困難になる。</p>
<p>そこで、ActiveRecordはスキーマファイルの形式にSQLを選ぶことができる。<code>config/application.rb</code>で以下のように指定すると、<code>db/structure.sql</code>というSQL形式のスキーマファイルが生成される。</p>
<pre><code class="lang-rb">config.active_record.schema_format = :sql
</code></pre>
<p>なお、この設定はデフォルトでは<code>:ruby</code>が指定されている。</p>
<p>SQL形式に変更した場合、コマンドを以下のように変える必要がある。</p>
<table>
<thead>
<tr>
<th>Ruby形式</th>
<th>SQL形式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rails db:schema:load</code></td>
<td><code>rails db:structure:load</code></td>
</tr>
<tr>
<td><code>rails db:schema:dump</code></td>
<td><code>rails db:structure:dump</code></td>
</tr>
</tbody>
</table>
<p>また、<code>db/structure.sql</code>の生成にはDBごとのスキーマダンプツールを使うため、MySQLであれば<code>mysqldump</code>を用意する必要がある。</p>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>Atom形式のフィードをサポートした</title>
    <link rel="alternate" href="https://naoty.github.io/posts/13.html"/>
    <id>https://naoty.github.io/posts/13.html</id>
    <updated>2018-01-12T21:08:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>Atom形式のフィードをサポートした。一覧画面と詳細画面の下部にあるリンクからアクセスできる。</p>
<p>Livedoor Reader時代からずっとRSSリーダーを使っており、今はFeedlyを使っている。Twitterやはてなブックマークのタイムラインでは、時間の経過とともに見逃してしまうが、RSSリーダーであれば未読がどんどん積まれるだけなので見逃す心配がなく、それが使い続けている理由になっている。</p>
<p>ブログを更新したとき自分でTwitterでリンクを公開するのがなんとなくこそばゆい気持ちになる。シェアしなければしないで、誰も気づかないだろうから、それも寂しい。だから、更新されたら勝手にフィードが生成されて通知される方が気が楽だ。これで他人の目を気にせずどんどん記事を更新できるし、読者との距離感を気にせずに済む。</p>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>よく使うLaTeXコマンド</title>
    <link rel="alternate" href="https://naoty.github.io/posts/12.html"/>
    <id>https://naoty.github.io/posts/12.html</id>
    <updated>2018-01-08T08:57:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>最近、Jupyter Notebookを使って機械学習を学び始めた。数式が頻繁に出てくるため、LaTeXを初めて使うようになった。</p>
<p>自分のためのメモとして、よく使う数式とその記法をまとめた。</p>
<table>
  <thead>
    <tr>
      <th>記法</th>
      <th>数式</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>$x^{-2}$</code></td>
      <td>$x^{-2}$</td>
    </tr>
    <tr>
      <td><code>$x_{12}$</code></td>
      <td>$x_{12}$</td>
    </tr>
    <tr>
      <td><code>$\frac{1}{2}$</code></td>
      <td>$\frac{1}{2}$</td>
    </tr>
    <tr>
      <td><code>$y = 2x + 1 \tag{1}$</code></td>
      <td>$y = 2x + 1 \tag{1}$</td>
    </tr>
    <tr>
      <td><code>$\frac{\partial L}{\partial W}$</code></td>
      <td>$\frac{\partial L}{\partial W}$</td>
    </tr>
    <tr>
      <td><pre><code>$$
\begin{align}
x + y = 3 \tag{1} \\
2x - y = 0 \tag{2}
\end{align}
$$</code></pre></td>
      <td>$$
\begin{align}
x + y = 3 \tag{1} \\
2x - y = 0 \tag{2}
\end{align}
$$</td>
    </tr>
    <tr>
      <td><pre><code>$$
y = \begin{cases}
x &amp; (x &gt; 0) \\
0 &amp; (x \leqq 0)
\end{cases}
$$</code></pre>
      </td>
      <td>$$
y = \begin{cases}
x &amp; (x &gt; 0) \\
0 &amp; (x \leqq 0)
\end{cases}
$$</td>
    </tr>
    <tr>
      <td><pre><code>$$
\sum_{i=0}^{k} x_{k}
$$</code></pre></td>
      <td>$$
\sum_{i=0}^{k} x_k
$$</td>
    </tr>
    <tr>
      <td><pre><code>$$
\begin{pmatrix}
1 &amp; 2 \\
3 &amp; 4
\end{pmatrix}
$$</code></pre></td>
      <td>$$
\begin{pmatrix}
1 &amp; 2 \\
3 &amp; 4
\end{pmatrix}
$$</td>
    </tr>
  </tbody>
</table>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>「みんなのPython」を読んだ</title>
    <link rel="alternate" href="https://naoty.github.io/posts/11.html"/>
    <id>https://naoty.github.io/posts/11.html</id>
    <updated>2017-12-31T11:42:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>年末年始はPythonや機械学習の勉強をしようと思い、<a href="http://amzn.to/2CpqmH1">みんなのPython</a>を読んだ。</p>
<p>数年間Rubyを書いているため、そこまで苦労せずPythonを学ぶことができた。1週間程度でざっと読了した。勉強になったことは次のようなことだった。</p>
<ul>
<li><code>int()</code>のような関数に見えるものは<code>int</code>という組み込みクラスのイニシャライザであること。</li>
<li>リスト内包表記やディクショナリ内包表記。これがあれば、<code>map</code>や<code>filter</code>といった関数型プログラミングでよく出てくる関数は不要そう。</li>
<li>モジュールとパッケージは、それぞれスクリプトファイルとそれを含むディレクトリであること。</li>
<li>Jupyter Notebookの使い方。これによって、今後のPythonの学習において効率的に試行錯誤やメモをとることができそう。</li>
<li>Python2系と3系の差。インターネットや少し古い書籍ではまだPython2系が使われていることがあるため、差を頭に入れておけば自分の中で変換ができるようになる。</li>
</ul>
<p>あとは、標準ライブラリや周辺知識を調べながらアプリケーションを作っていけばPythonを書けるようになりそう。</p>
<p>次は<a href="http://amzn.to/2CkUR0N">ゼロから作るDeep Learning</a>を読むことにした。</p>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>画像アップロードの実装パターン</title>
    <link rel="alternate" href="https://naoty.github.io/posts/10.html"/>
    <id>https://naoty.github.io/posts/10.html</id>
    <updated>2017-12-22T17:12:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>画像アップロードの実装は考えれば考えるほど難しい。サーバーサイドはもちろんのこと、インフラやフロントエンドにわたって幅広く知識が求められる。</p>
<p>これまでの経験を基に画像アップロードの実装パターンを3パターンにまとめてみた。</p>
<ol>
<li>同期アップロード</li>
<li>非同期アップロード</li>
<li>ダイレクトアップロード</li>
</ol>
<p>以下では、画像のアップロード先としてS3を想定する。また、画像のリサイズについては、画像リクエスト時にリサイズする方法などを考慮に加えると論点が発散しそうなので、いったん保留する。</p>
<h1 id="-">同期アップロード</h1>
<p><img src="/images/posts/10/synchronous-upload.png" alt="同期アップロードのシーケンス図"></p>
<p>同期アップロードは、リクエストを受け取ったサーバーがS3に画像をアップロードするまでクライアントを待たせる。</p>
<p>そのため、非常に大きい画像や複数の画像をアップロードした場合、レスポンスタイムが非常に長くなることが予想できる。通常、Webサーバーはリクエストボディのサイズに上限を設定したり、リクエストのタイムアウト時間を設定しているため、そのようなリクエストはタイムアウトになってしまうだろう。</p>
<p>同期アップロードの実装は非同期アップロードに比べると簡単だし、非同期処理に伴う問題もない。だから、社内システムのようにユーザーを待たせても問題がない場合は同期アップロードを採用してもいいと思う。だけど、UI/UXが非常に悪いため、ユーザーが使う機能の実装としては採用できないと思う。</p>
<h1 id="-">非同期アップロード</h1>
<p><img src="/images/posts/10/asynchronous-upload.png" alt="非同期アップロードのシーケンス図"></p>
<p>非同期アップロードは、リクエストを受け取ったサーバーとは別のワーカープロセスがバックグラウンドで画像をアップロードする。そのため、クライアントがレスポンスを受け取った時点ではアップロードが完了していない可能性がある。</p>
<p>同期アップロードと比べると、レスポンスタイムが改善され、複数の画像をアップロードすることも可能になる。しかし、非同期アップロードを実装するにあたり、考えなくてはいけないことがいくつかある。</p>
<ul>
<li>アップロードが失敗した場合にリトライさせる手段をどのように提供するか（UI/UX観点）。</li>
<li>ジョブキューとワーカープロセス、そしてワーカープロセスを管理するプロセスをどのように開発時に用意するか（開発環境観点）。</li>
<li>サーバーとワーカーの間でどのようにアップロードされた画像を受け渡すか（インフラ観点）。</li>
</ul>
<p>それぞれの論点は、それだけで十分に1つの記事になりうるため、ここでは論点を挙げるだけに留めておきたい。</p>
<h1 id="-">ダイレクトアップロード</h1>
<p><img src="/images/posts/10/direct-upload.png" alt="ダイレクトアップロードのシーケンス図"></p>
<p>ダイレクトアップロードは、クライアントからサーバーを介さずに直接S3にアップロードし、完了後にファイルパスなどの情報のみサーバーに送る。</p>
<p>この方法でも、同期アップロードのようにクライアントを待たせるようなことはなく、複数の画像をアップロードできる。さらに、非同期アップロードのような複雑なアーキテクチャも必要がないため、スマートな方法のように思える。</p>
<p>この場合、画像をサーバーで処理できないため、画像のファイル形式の検証やウイルススキャンなどをクライアントで行う必要がある。アプリであればiOSとAndroid両方で実装が必要になるため、全体の実装工数は3つの実装パターンの中で最も大きいかもしれない。</p>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>todoをtmuxで表示する</title>
    <link rel="alternate" href="https://naoty.github.io/posts/9.html"/>
    <id>https://naoty.github.io/posts/9.html</id>
    <updated>2017-12-22T13:34:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p><img src="/images/posts/9/todo.gif" alt="次のtodoをtmuxのstatus lineに表示する"></p>
<p><a href="https://github.com/naoty/todo">naoty/todo</a>に改良して、上のスクリーンキャストのようにtmuxのstatus lineに次のtodoを表示できるようにしてみた。</p>
<p><code>next</code>というコマンドを追加し、最も優先順位の高いtodoを表示できるようにした。また、<code>done</code>コマンドに引数を指定しない場合に<code>next</code>で表示されるtodoを完了できるようにした。<code>done</code>コマンドなどで次のtodoが変わっても、tmuxが自動的に更新してくれるのですぐに切り替わる。</p>
<p>iTerm2の画面分割を使っていたためtmuxは使ってこなかったが、status lineに次のtodoを表示するアイデアを思いついたため使い始めた。この使い方によって、次にやることを<code>list</code>コマンドで何度も確認する必要がなくなったし、次にやるべきことのみに集中できるため、とてもいい。</p>
<h1 id="-">導入方法</h1>
<p>まず、<a href="https://github.com/naoty/todo">naoty/todo</a>をインストールする。</p>
<pre><code class="lang-bash">$ brew tap naoty/misc
$ brew install todo
</code></pre>
<p>次に.tmux.confを以下のように修正する。</p>
<pre><code class="lang-conf">set-option -g status-right-length 80
if-shell &#39;which todo&#39; &#39;set-option -g status-right &quot;next: #(todo next)&quot;&#39;
</code></pre>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>2017年に作ったもの</title>
    <link rel="alternate" href="https://naoty.github.io/posts/8.html"/>
    <id>https://naoty.github.io/posts/8.html</id>
    <updated>2017-12-21T23:00:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>2017年も終わろうとしているので、今年作ったものを振り返ってみた。こうやって振り返ってみると、今年もたくさん作った。今も使っているものもあるし、使っていないものもある。</p>
<p>自分が抱えている問題を自分のコードで解決できるというのは、豊かな体験だとおもっている。来年も続けていけるように今年を振り返る。</p>
<h1 id="-">使っているもの</h1>
<h2 id="-table-https-github-com-naoty-table-"><a href="https://github.com/naoty/table">table</a></h2>
<pre><code class="lang-bash">$ echo &quot;day\tDAU\n2017-01-01\t10000\n2017-01-02\t8000&quot; | table -H
+------------+-------+
| day        | DAU   |
+------------+-------+
| 2017-01-01 | 10000 |
| 2017-01-02 | 8000  |
+------------+-------+
</code></pre>
<p><code>table</code>はタブ区切りの文字列をASCIIのテーブル形式に変換する。Google Spreadsheetなど表形式のテキストをSlackにコピペしたくて作った。そんなに使う頻度は多くないけど、使うときはとても便利でたまに使う。</p>
<h2 id="-homebrew-misc-https-github-com-naoty-homebrew-misc-"><a href="https://github.com/naoty/homebrew-misc">homebrew-misc</a></h2>
<pre><code class="lang-bash">$ brew tap naoty/misc
</code></pre>
<p>自作のちょっとしたツールを簡単にインストール・アンインストールするためにリポジトリを作った。今年作ったツールはここからHomebrewでインストールできるようにした。プライベートのPCで作ったツールを業務用のPCでインストールするときにラクなので作ってよかった。</p>
<h2 id="fish-">fish-*</h2>
<p>fishのためのプラグインをいくつか書いた。今年からzshからfishに移行した。fishにはfishermanというプラグイン管理ツールがあり、簡単にfishの機能を拡張できる。pecoを使ったスクリプトやプロンプトまでプラグインとして作った。</p>
<h2 id="-license-https-github-com-naoty-license-"><a href="https://github.com/naoty/license">license</a></h2>
<pre><code class="lang-bash">$ license &gt; LICENSE
</code></pre>
<p>MITのLICENSEファイルを出力するだけのツール。新しいリポジトリを作るときは初手で上を実行している。</p>
<h2 id="-git-misc-https-github-com-naoty-git-misc-"><a href="https://github.com/naoty/git-misc">git-misc</a></h2>
<pre><code class="lang-bash">$ git prune-branch
$ git tag-timestamp
</code></pre>
<p>git-miscにはgit関連のスクリプトがいくつか入っている。その中でも<code>git-prune-branch</code>という不要なbranchを削除するコマンドはほぼ毎日使っている気がする。</p>
<h2 id="-nippo-https-github-com-naoty-nippo-"><a href="https://github.com/naoty/nippo">nippo</a></h2>
<pre><code class="lang-bash">$ nippo
</code></pre>
<p><code>nippo</code>はその名の通り日報を作るためのスクリプト。<code>2017-12-21.md</code>のようなファイル名でファイルを作成してエディタを起動する。今年は10月くらいから毎日日報をつけるようにした。このスクリプトのおかげで続いていると言っても過言ではないと思う。</p>
<h2 id="-icon-https-github-com-naoty-icon-"><a href="https://github.com/naoty/icon">icon</a></h2>
<pre><code class="lang-bash">$ icon
</code></pre>
<p><code>icon</code>は自分のアイコンを生成するためのツール。引数を指定することで自由なサイズで生成できるので、ダミー画像を作る用途でも使える。</p>
<h2 id="-homepage-https-github-com-naoty-homepage-"><a href="https://github.com/naoty/homepage">homepage</a></h2>
<p>このGitHub Pagesを管理するためのリポジトリ。既存の静的サイトジェネレーターを使わずにGulpプラグインだけでページを生成するようにしている。おかげで自由にカスタマイズすることができており、いまのところこのGitHub Pagesに移行してよかったと思っている。</p>
<h1 id="-">使ってないもの</h1>
<h2 id="-flock-https-github-com-naoty-flock-"><a href="https://github.com/naoty/flock">flock</a></h2>
<p><code>flock</code>はSwiftのソースコードから依存関係を抽出し、dot形式のファイルを出力する。今年はほとんどSwiftを書いていないので使う機会がなかった。</p>
<h2 id="-task-https-github-com-naoty-task-"><a href="https://github.com/naoty/Task">Task</a></h2>
<p>TaskはWebフロントエンドの技術を学ぶために作ったElectronアプリで、<a href="https://github.com/naoty/todo">naoty/todo</a>のGUI版を意識して作った。CUIをそのままGUIにしただけでは、利便性ではCUIの方が優れていたため使うことはなかった。もう少しGUIの良さを活かしたタスク管理アプリケーションを作ってみたい。</p>
<h2 id="-focus-theme-https-github-com-naoty-focus-theme-"><a href="https://github.com/naoty/focus-theme">focus-theme</a></h2>
<p>はてなブログのために作ったテーマ。CSSの勉強のために書いてみた。結局、後述するGitHub Pagesに移行したため使わなくなった。</p>
<h2 id="-brewery-https-github-com-naoty-brewery-"><a href="https://github.com/naoty/brewery">brewery</a></h2>
<p><code>brewery</code>はHomebrewのformulaを作るためのツール。SHA256を生成するのがだんだんつらくて作ったけど、<code>shasum</code>を知ってから使う必要がなくなってしまった。</p>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>Circle CI 2.0への移行作業</title>
    <link rel="alternate" href="https://naoty.github.io/posts/7.html"/>
    <id>https://naoty.github.io/posts/7.html</id>
    <updated>2017-12-12T22:35:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>最近、RailsプロジェクトをCircle CI 2.0へ移行した。「テスト→Dockerイメージのビルド→レジストリへのPush」というワークフローを作った。</p>
<pre><code class="lang-yml">workflows:
  version: 2
  build:
    jobs:
      - test
      - build-image:
          requires:
            - test
      - push-image:
          requires:
            - build-image
</code></pre>
<h1 id="-">テスト</h1>
<p>テストでは、Circle CIのイメージを使うか、テスト前にDockerイメージをビルドしてそれをテストに使うか、というところで迷った。</p>
<p>前者の場合、<code>circleci/ruby:2.4.2</code>のようなイメージを利用する。メリットとしては、テストが通ったコードのみDockerイメージをビルドするため、失敗した場合により速く完了する。僕のプロジェクトでは、Dockerイメージのビルドが最も時間がかかるため、この方法を採った。</p>
<p>後者の場合、上記のようなワークフローの順番を入れ替えて、ビルドしたDockerイメージを<code>docker save</code>で永続化し、テスト前に<code>docker load</code>で再利用するような形になりそう。メリットとしては、開発環境とテスト環境（そして理想的には本番環境）をすべて揃えることができる。Dockerイメージのポータビリティを活かした方法だと思う。一方で、上記の通りDockerイメージのビルドに時間がかかる場合にワークフロー全体の完了に時間がかかってしまう。</p>
<h1 id="docker-">Dockerイメージのビルド</h1>
<p>Dockerイメージのビルドは最も時間がかかる部分だった。Dockerイメージのビルドはどの環境で行うのがベターなのかベストプラクティスが分からなかった。GCRにpushする都合で、<code>google/cloud-sdk</code>をDockerイメージとして使い、コンテナ上でDockerイメージをビルドすることになった。</p>
<p>Circle CI 2.0では、<code>setup_remote_docker</code>というコマンドを使うことでコンテナと別の環境にDockerデーモンを起動しDockerイメージのビルドを行うことができる（<a href="https://circleci.com/docs/2.0/building-docker-images/">参考</a>）。課金してサポートに連絡すれば、過去のビルドで利用したレイヤーをキャッシュして再利用することができる。これを有効にできると、Dockerイメージのビルドを超高速化できそう。</p>
<h1 id="-push">レジストリへのPush</h1>
<p>僕のプロジェクトでは、GCRにビルドしたDockerイメージをPushしている。先述の通り、これを簡単に行うために<code>google/cloud-sdk</code>のDockerイメージを利用している。GCRを使う場合の<a href="https://circleci.com/docs/2.0/google-container-engine/">ドキュメント</a>を参考に設定をし、無事に移行できた。</p>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>ActiveRecordのattributeメソッド</title>
    <link rel="alternate" href="https://naoty.github.io/posts/6.html"/>
    <id>https://naoty.github.io/posts/6.html</id>
    <updated>2017-12-08T23:00:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <pre><code class="lang-rb">class User
  attribute :unencrypted_password, :string
end
</code></pre>
<ul>
<li><code>attribute</code>メソッドはモデルに属性を追加する。</li>
<li>DBのカラムがなくても追加できる。</li>
<li>DBのカラムのアクセサをoverrideすることもできる。</li>
</ul>
<h1 id="-validation">例：パスワードのvalidation</h1>
<p>パスワードのvalidationを実装する場合を考える。パスワードのvalidationというのは、暗号化される前の値に対して行われる。生パスワードはDBに保存しないが、アクセサがあると便利なので<code>attribute</code>メソッドで追加する。<code>attribute</code>メソッドで追加した仮想的なカラムにはvalidationが使える。</p>
<pre><code class="lang-rb">class User
  attribute :unencrypted_password, :string

  before_save :encrypt_password, if: unencrypted_password_changed?

  validates :unencrypted_password,
    format: { with: /\A[0-9a-zA-Z]\z/ },
    length: { minimum: 8, maximum: 36 },
    presence: true

  private

  def encrypt_password
    cost = BCrypt::Engine.cost
    self.password = BCrypt::Password.create(unencrypted_password, cost)
  end
end
</code></pre>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>GitHub Pagesの更新をCIで自動化した</title>
    <link rel="alternate" href="https://naoty.github.io/posts/5.html"/>
    <id>https://naoty.github.io/posts/5.html</id>
    <updated>2017-12-08T00:04:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>GitHub Pagesの管理が煩雑だったため、Circle CIで自動化した。</p>
<p>これまでは<a href="https://github.com/naoty/naoty.github.io">GitHub Pagesのリポジトリ</a>を<a href="https://github.com/naoty/homepage">管理リポジトリ</a>のサブモジュールとして管理していたが、サブモジュールはいろいろと作業が面倒だった。サブモジュールと本体の両方をgitでコミットするのがとにかく面倒だった。</p>
<p>最近、仕事でCircle CI 2.0の対応をしているため、このブログの更新もCIに任せることができそうだと思い、さっそく設定をした。以下、ハマったところとか工夫したところとか。</p>
<ul>
<li>GitHub pagesのリポジトリをcloneする必要があったが、その際にSSH接続で<code>Are you sure you want to continue connecting (yes/no)?</code>と聞かれてしまい、ビルドが止まってしまった。そこで、以下のようにすることで回避した。</li>
</ul>
<pre><code class="lang-yaml">- run:
    name: SSH settings
    command: mkdir ~/.ssh/ &amp;&amp; echo -e &quot;Host github.com\n\tStrictHostKeyChecking no\n&quot; &gt; ~/.ssh/config
</code></pre>
<ul>
<li>Circle CIで他のリポジトリにアクセスするには鍵を追加する必要があるため、設定画面から鍵を追加した。</li>
<li>Circle CI上でgit commitする際に<code>username/repo@commit_id</code>の記法をメッセージに追加することで、GitHub pagesのコミットメッセージから対応する管理リポジトリのコミットに辿れるようにした。</li>
</ul>
<p>config.ymlは今のところ以下のようになっている。<code>npm install</code>でキャッシュを使っていないけど、そこらへんは徐々に最適化していきたい。</p>
<pre><code class="lang-yaml">version: 2
jobs:
  build:
    docker:
      - image: circleci/node
    steps:
      - run:
          name: SSH settings
          command: mkdir ~/.ssh/ &amp;&amp; echo -e &quot;Host github.com\n\tStrictHostKeyChecking no\n&quot; &gt; ~/.ssh/config
      - run:
          name: Clone GitHub pages
          command: |
            git clone git@github.com:naoty/naoty.github.io.git .
            git config user.email &quot;naoty.k@gmail.com&quot;
            git config user.name &quot;Naoto Kaneko&quot;
          working_directory: ~/naoty.github.io
      - checkout
      - run: npm install
      - run: npm run build
      - run:
          name: Publish GitHub pages
          command: |
            cp -pr public/* ~/naoty.github.io/
            cd ~/naoty.github.io
            git add .
            git commit -m &quot;Publish naoty/homepage@${CIRCLE_SHA1}&quot;
            git push origin master
</code></pre>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>ブログで使うHTML5</title>
    <link rel="alternate" href="https://naoty.github.io/posts/4.html"/>
    <id>https://naoty.github.io/posts/4.html</id>
    <updated>2017-12-03T20:03:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>ブログを作るにあたって適切なセマンティックを使おうと思い、HTML5のタグを調べた。</p>
<h1 id="-">レイアウト</h1>
<pre><code class="lang-html">&lt;article&gt;
  &lt;header&gt;
    &lt;h1&gt;ブログタイトル&lt;/h1&gt;
    &lt;p&gt;公開：&lt;time datetime=&quot;2017-12-01T12:00:00.000+0900&quot;&gt;2017-12-01 12:00:00&lt;/time&gt;&lt;/p&gt;
  &lt;/header&gt;
  &lt;section&gt;
    &lt;h1&gt;見出し1&lt;/h1&gt;
    &lt;p&gt;本文&lt;/p&gt;
  &lt;/section&gt;
  &lt;footer&gt;
    &lt;p&gt;&lt;a href=&quot;/&quot;&gt;トップ&lt;/a&gt;&lt;/p&gt;
  &lt;/footer&gt;
&lt;/article&gt;
</code></pre>
<ul>
<li><code>&lt;article&gt;</code>：ブログのエントリーを表すために使う。</li>
<li><code>&lt;header&gt;</code>, <code>&lt;footer&gt;</code>：ブログのヘッダーおよびフッターを表すために使う。このブログでは、ブログタイトルやメタデータをヘッダーに表示して、ナビゲーションのリンクをフッターに表示している。</li>
<li><code>&lt;section&gt;</code>：ブログ本文をヘッダーやフッターと区別して表すために使う。</li>
<li><code>&lt;time&gt;</code>：ブログのエントリーの公開日時を表すために使う。<code>datetime</code>属性によって公開日時を指定できる。</li>
</ul>
<h1 id="-">コード</h1>
<pre><code class="lang-html">&lt;figure&gt;
  &lt;figcaption&gt;app/models/pokemon.rb&lt;/figcaption&gt;
  &lt;pre&gt;
    &lt;code class=&quot;ruby&quot;&gt;
    &lt;/code&gt;
  &lt;/pre&gt;
&lt;/figure&gt;
</code></pre>
<ul>
<li><code>&lt;figure&gt;</code>：文書とは別に参考資料として付け加えたコンテンツを表すために使う。画像やコードに対して使えるようだ。</li>
<li><code>&lt;figcaption&gt;</code>：参考資料のキャプションを表すために使う。</li>
</ul>
<h1 id="-">画像</h1>
<pre><code class="lang-html">&lt;figure&gt;
  &lt;figcaption&gt;図1&lt;/figcaption&gt;
  &lt;picture&gt;
    &lt;source srcset=&quot;/figure1-large.png, /figure1-large@2x.png 2x&quot; media=&quot;(min-width: 600px)&quot;&gt;
    &lt;img src=&quot;/figure1.png&quot; srcset=&quot;/figure1.png, /figure1@2x.png 2x&quot; alt=&quot;図1&quot;&gt;
  &lt;/picture&gt;
&lt;/figure&gt;
</code></pre>
<ul>
<li><code>&lt;picture&gt;</code>：条件に合わせて表示する画像を切り替えることができる。レスポンシブデザインをサポートしたり、画像の最適化のために使う。</li>
<li><code>&lt;source&gt;</code>：複数のリソースを指定するために使う。</li>
</ul>
<h1 id="-">その他</h1>
<ul>
<li><code>&lt;ins&gt;</code>：追記されたテキストを表すために使う。<code>datetime</code>属性に追記日時を指定できる。</li>
<li><code>&lt;del&gt;</code>：削除されたテキストを表すために使う。<code>datetime</code>属性に削除日時を指定できる。</li>
</ul>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>モデルに記述する順番</title>
    <link rel="alternate" href="https://naoty.github.io/posts/3.html"/>
    <id>https://naoty.github.io/posts/3.html</id>
    <updated>2017-12-02T23:02:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>他のメンバーがコードを読むときに知っておいてほしいことを意識して、以下の順に書いている。</p>
<ol>
<li>モジュール</li>
<li>定数</li>
<li>関連</li>
<li>属性（<code>enum</code>, <code>attribute</code>など）</li>
<li>コールバック</li>
<li>バリデーション</li>
<li>スコープ</li>
<li>クラスメソッド</li>
<li>インスタンスメソッド</li>
<li>プライベートメソッド</li>
</ol>
<p>以下のコードは例のために書いてみたけど、動くかわからない。</p>
<pre><code class="lang-rb">class Pokemon &lt; ApplicationRecord
  include Tradable

  INITIAL_HP_RANGE = 10..20

  belongs_to :master
  has_many :skills

  enum gender: %i[male female]

  before_validation :set_initial_hp, on: :create

  validates :name, presence: true
  validates :hp, numericality: { greater_than_or_equal_to: 0 }

  scope :first_generation, -&gt; { where(id: (1..151).to_a) }

  def self.capture
    # ...
  end

  def attack
    # ...
  end

  private

  def set_initial_hp
    self.hp = rand(INITIAL_HP_RANGE)
  end
end
</code></pre>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>モデルの差分更新</title>
    <link rel="alternate" href="https://naoty.github.io/posts/2.html"/>
    <id>https://naoty.github.io/posts/2.html</id>
    <updated>2017-12-01T21:40:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>アプリからデータのバックアップを受け取るときに、サーバー側で差分更新を行う必要がある。全部消去してから全部挿入するという実装も考えられるが、何かの実装ミスの際に全消去してしまうリスクがありそうなので避けたい。</p>
<p>新しいデータと既存のデータを比較して、以下のような操作をする必要がある。</p>
<ul>
<li>新しいデータにも既存のデータにもあるデータを更新する。</li>
<li>新しいデータにあるが、既存のデータにないデータを挿入する。</li>
<li>新しいデータにないが、既存のデータにあるデータを削除する。</li>
</ul>
<p>これを実行するロジックをあらためて考えてみた。</p>
<pre><code class="lang-rb">new_users = [{ id: 1, name: &quot;...&quot; }, { id: 2, name: &quot;...&quot; }]
new_users_index = new_users.index_by { |new_user| new_user[:id] }

User.all.in_batches do |users|
  users.each do |user|
    # インデックスから取得できたデータは取り除いていく
    # 残ったデータはINSERT時に利用する
    new_user = new_users_index.delete(user.id)

    # 新しいデータに含まれているかチェック
    if new_user.nil?
      # 含まれていなければDELETE
      user.destroy
    else
      # 含まれていればUPDATE
      user.update_attributes(new_user)
    end
  end
end

# 残ったデータはすべてINSERTする
new_users_index.values.each do |new_user|
  User.create(new_user)
end
</code></pre>

      </div>
    </content>
  </entry>
  
  <entry>
    <title>GitHub Pagesに移行した</title>
    <link rel="alternate" href="https://naoty.github.io/posts/1.html"/>
    <id>https://naoty.github.io/posts/1.html</id>
    <updated>2017-11-29T17:12:00.000+09:00</updated>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
        <p>ブログをはてなブログからGitHub Pagesに移行した。</p>
<p>dev.toを見てからWebプログラマーのブログは高速に表示されるべきだと思うようになったので、GitHub Pagesに移行して、マークアップからすべてフルスクラッチすることにした。</p>
<p>移行にあたっていくつかStatic Site Generatorを試してみたが、どれもしっくりこなかったので、gulpのプラグインを組み合わせてHTMLやCSSを組み立てることにした。コードは<a href="https://github.com/naoty/homepage">naoty/homepage</a>にある。</p>
<p>以下、やったこととか気をつけたこと。</p>
<ul>
<li>ページの各コンテンツをmarkdownで書くようにして、ejsで書いたレイアウトに展開するようにした。これは既存のgulpプラグインではできなかったため、独自にgulpプラグインを書いた。</li>
<li>各投稿からindexページを生成するようにした。ejsで書いたレイアウトに展開するようになっている。また、同時にファイルのmtimeを見てソートするようにしている。これも独自のgulpプラグインを書いて実現した。</li>
<li>CSSはSASSで書いてCSSに変換して圧縮している。CSSはすべてHTMLの<code>&lt;style&gt;</code>タグ内につっこんでいる。こうすることで、CSSのレンダリングブロックを回避できるため、初回のレンダリングが少し速くなる。</li>
<li>CSSを書く際に、モバイルファーストを念頭にまずスマホ表示を前提に書き始めた。そして、画面を広げながら、余白が気になる部分でメディアクエリを使って広い画面向けのスタイルを追加している。</li>
<li>最終的なHTMLは圧縮している。ここらへん、できる限りファイルサイズを抑えてパフォーマンスを最適化しようとしている。結果的に、PageSpeed Insightsでほぼ100点をとれるようになった。</li>
</ul>
<p><img src="/images/posts/1/pagespeed-insights.png" alt="pagespeed-insights"></p>
<ul>
<li>ファイル名をURLに使おうとすると、濁点や半濁点を含むファイル名が表示できなくなることがある。これは、macOSのファイル名はUTF-8-MACと呼ばれるエンコーディングが使われているためで、濁点や半濁点が通常のUTF-8と異なるために起きているらしい。</li>
<li>ファイル名には自然数を使うようにし、タイトルはfront matterで指定するようにした。front matterでは、タイトルの他に<code>description</code>や<code>og:image</code>を設定できるようにした。</li>
<li>Lighthouseを参考にmanifest.jsonを書くなどPWAの要件を満たすようにした。</li>
</ul>
<p><img src="/images/posts/1/lighthouse.png" alt="lighthouse"></p>
<ul>
<li><a href="https://github.com/naoty/homepage">naoty/homepage</a>のpublicディレクトリをgitサブモジュールにして<a href="https://github.com/naoty/naoty.github.io">naoty/naoty.github.io</a>にpushするようにしている。</li>
</ul>

      </div>
    </content>
  </entry>
  
</feed>
