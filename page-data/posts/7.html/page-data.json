{"componentChunkName":"component---src-templates-post-jsx","path":"/posts/7.html","webpackCompilationHash":"3f0085c6f69d42a83bf9","result":{"data":{"site":{"siteMetadata":{"rootURL":"https://naoty.github.io"}},"markdownRemark":{"frontmatter":{"title":"Circle CI 2.0への移行作業","time":"2017-12-12T22:35:00+0900","description":"RailsプロジェクトをCircle CI 2.0に移行した","tags":["circleci"]},"html":"<p>最近、RailsプロジェクトをCircle CI 2.0へ移行した。「テスト→Dockerイメージのビルド→レジストリへのPush」というワークフローを作った。</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">workflows</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token number\">2</span>\n  <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> test\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">build-image</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">requires</span><span class=\"token punctuation\">:</span>\n            <span class=\"token punctuation\">-</span> test\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">push-image</span><span class=\"token punctuation\">:</span>\n          <span class=\"token key atrule\">requires</span><span class=\"token punctuation\">:</span>\n            <span class=\"token punctuation\">-</span> build<span class=\"token punctuation\">-</span>image</code></pre></div>\n<h1>テスト</h1>\n<p>テストでは、Circle CIのイメージを使うか、テスト前にDockerイメージをビルドしてそれをテストに使うか、というところで迷った。</p>\n<p>前者の場合、<code class=\"language-text\">circleci/ruby:2.4.2</code>のようなイメージを利用する。メリットとしては、テストが通ったコードのみDockerイメージをビルドするため、失敗した場合により速く完了する。僕のプロジェクトでは、Dockerイメージのビルドが最も時間がかかるため、この方法を採った。</p>\n<p>後者の場合、上記のようなワークフローの順番を入れ替えて、ビルドしたDockerイメージを<code class=\"language-text\">docker save</code>で永続化し、テスト前に<code class=\"language-text\">docker load</code>で再利用するような形になりそう。メリットとしては、開発環境とテスト環境（そして理想的には本番環境）をすべて揃えることができる。Dockerイメージのポータビリティを活かした方法だと思う。一方で、上記の通りDockerイメージのビルドに時間がかかる場合にワークフロー全体の完了に時間がかかってしまう。</p>\n<h1>Dockerイメージのビルド</h1>\n<p>Dockerイメージのビルドは最も時間がかかる部分だった。Dockerイメージのビルドはどの環境で行うのがベターなのかベストプラクティスが分からなかった。GCRにpushする都合で、<code class=\"language-text\">google/cloud-sdk</code>をDockerイメージとして使い、コンテナ上でDockerイメージをビルドすることになった。</p>\n<p>Circle CI 2.0では、<code class=\"language-text\">setup_remote_docker</code>というコマンドを使うことでコンテナと別の環境にDockerデーモンを起動しDockerイメージのビルドを行うことができる（<a href=\"https://circleci.com/docs/2.0/building-docker-images/\">参考</a>）。課金してサポートに連絡すれば、過去のビルドで利用したレイヤーをキャッシュして再利用することができる。これを有効にできると、Dockerイメージのビルドを超高速化できそう。</p>\n<h1>レジストリへのPush</h1>\n<p>僕のプロジェクトでは、GCRにビルドしたDockerイメージをPushしている。先述の通り、これを簡単に行うために<code class=\"language-text\">google/cloud-sdk</code>のDockerイメージを利用している。GCRを使う場合の<a href=\"https://circleci.com/docs/2.0/google-container-engine/\">ドキュメント</a>を参考に設定をし、無事に移行できた。</p>","fileAbsolutePath":"/home/circleci/project/contents/posts/7.md"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"64f43e54-dda8-57c4-981f-71737ac08f41"}}}