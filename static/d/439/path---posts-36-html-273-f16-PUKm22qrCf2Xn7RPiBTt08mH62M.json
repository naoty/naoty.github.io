{"data":{"site":{"siteMetadata":{"rootURL":"https://naoty.github.io"}},"markdownRemark":{"frontmatter":{"title":"決定境界のプロット","time":"2018-07-22T15:02:00+0900","description":"numpyやmatplotlibを使って決定境界をプロットする方法を学んだ","tags":null},"html":"<p>ロジスティック回帰など分類を行うアルゴリズムがちゃんとトレーニングデータを分類できているか確認するため、決定境界をプロットする方法を学んだ。そのメモをブログに残す。</p>\n<h2>まとめ</h2>\n<ul>\n<li><code class=\"language-text\">np.meshgrid()</code>で格子点を取得する。しかも、<code class=\"language-text\">np.arange()</code>などを使ってできるだけ細かく格子点を取得する。</li>\n<li>格子点を分類器に適用するため、トレーニングデータの形状に変換する。</li>\n<li>格子点に対して分類を予測する。</li>\n<li>格子点とその分類の予測を<code class=\"language-text\">plt.contourf()</code>を使って等高線としてプロットする。</li>\n</ul>\n<h2>格子点の取得</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">x1 = np.arange(0, 5, 0.5)\nx2 = np.arange(0, 10, 0.5)\nX1, X2 = np.meshgrid(x1, x2)\n\nplt.plot(X1, X2, &#39;ok&#39;)\nplt.xlimit(-1, 11)\nplt.ylimit(-1, 11)\nplt.show()</code></pre></div>\n<p><img src=\"/images/posts/36/meshgrid.png\" alt=\"meshgrid\"></p>\n<p>上のように<code class=\"language-text\">np.meshgrid()</code>を使うと、2つの配列<code class=\"language-text\">x1</code>と<code class=\"language-text\">x2</code>からなる平面上にある格子点を取得できる。</p>\n<p>この格子点の間隔を小さくすると、<code class=\"language-text\">x1</code>と<code class=\"language-text\">x2</code>からなる平面上の「すべての点」を擬似的に再現できる。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">x1 = np.arange(0, 5, 0.01)\nx2 = np.arange(0, 10, 0.01)\n\n# 以下同じ</code></pre></div>\n<p><img src=\"/images/posts/36/dense_meshgrid.png\" alt=\"dense meshgrid\"></p>\n<h2>格子点の変換</h2>\n<p>ある平面上の「すべての点」を分類器に適用すると、平面上に分類した結果をマッピングできるようになる。</p>\n<p>そのために格子点をトレーニングデータの形状に変換する。つまり、$(x<em>1, x</em>2)$のようにする。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># flatにする\nX1_flatten = X1.ravel()\nX2_flatten = X2.ravel()\n\n# 結合して行列にする\nX = np.array([X1_flatten, X2_flatten])\n\n# 行方向がトレーニングデータ、列方向がフィーチャーになるように転置する\nX = X.T</code></pre></div>\n<h2>格子点を分類器に適用する</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Z = classifier.predict(X)</code></pre></div>\n<p>上で分類器に適用できるように変換できたので、あとは予測する。</p>\n<h2>等高線図でプロットする</h2>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># プロットできるように形状を揃える\nZ = Z.reshape(X1.shape)\n\nplt.contourf(X1, X2, Z, cmap=&#39;RdBu&#39;, alpha=0.5)\nplt.xlim(-1, 11)\nplt.ylim(-1, 11)\nplt.xlabel(&#39;x1&#39;)\nplt.ylabel(&#39;x2&#39;)\nplt.show()</code></pre></div>\n<p><img src=\"/images/posts/36/decision_regions.png\" alt=\"decision regions\"></p>\n<p><em>（上図は適当な関数を適用しただけです）</em></p>\n<p><code class=\"language-text\">plt.contourf()</code>は等高線図を引きつつ、領域を塗りつぶしてくれるので決定境界をプロットするのに便利。</p>","fileAbsolutePath":"/home/circleci/project/contents/posts/36.md"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"cba130fd-9508-54ef-b424-f512bd979a6d"}}